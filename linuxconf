#!/bin/bash

function echo2 () {
    echo "$@" 1>&2
}
function err () {
    echo2 Error: "$@"
    return 1
}
function die () {
    err "$@"
    exit 1
}

lc_include conf.d/*

function lc_include () {
    # for every included shell script, spawn sub shell,
    #   in the subshell, source the script, call (eval) the function name specified by global variable $LCI_SUBSHELL_OP
    # print the return code of the eval-ed function to stderr, but this function should always return success.

    for script in "$@"; do
        (
            source "$script"
            eval "$LCI_SUBSHELL_OP"
        )
        echo2 "$script -- $LCI_SUBSHELL_OP completed. return_val = $return_code"
    done

    return 0
}

# Example usage:
# LCI_SUBSHELL_OP="your_function_name"
# lc_include conf.d/*


function lc_assert_user_is () {
    # todo
}
function lc_assert_user_is_not () {
    # todo
}

#function lc_init () {
#    # as root / as user?
#
#    # note: in demo, append /etc/profile for PATH
#}
#
#function lc_startup () {
#    # as root / as user?
#    # with desktop env? (not supported yet)
#
#}
#
#function lc_login () {
#    # warning: less useful. happens again if user logout/login again. (not supported yet)
#    lc_login_is_x11?
#}
#
#function lc_cron () {
#    # hourly / daily / weekly / monthly?
#    # as root / as user?
#    $ how to allow user set 'every 2m' or 'every 1d'?
#
#}

# Warning: watch out for unintended user
lc_fsmap files/vimrc $LC_USER_HOME/.vimrc

function lc_fsmap () {
    # If existing symlink is correct, do nothing & return 0 (success).
    # Otherwise, delete the existing symlink. If the existing item is file/folder, move to '$filename.linuxsync_backup'.
    # Then create a symlink.

    local content_path="$(realpath "$1")"
    local symlink_path="$2"

    if [ -L "$symlink_path" ]; then
        if [ "$(readlink "$symlink_path")" = "$content_path" ]; then
            return 0
        else
            rm "$symlink_path" || return $?
        fi
    elif [ -e "$symlink_path" ]; then
        mv "$symlink_path" "${symlink_path}.linuxsync_backup" || rm -f "$symlink_path" || return $?
    fi

    ln -s "$content_path" "$symlink_path"
}

function lci_state_file_append () {
    local fname="$1"
    local prefix="$2"
    local uname="$3"

    echo "${prefix}_u_$uname=1" | tee -a "$fname"
    return $?
}
function lci_state_file_contains () {
    local fname="$1"
    local prefix="$2"
    local uname="$3"

    grep "^${prefix}_u_$uname=1" "$fname"
    return $?
}
function lci_state_file_list () {
    # stdout: uname list
    local fname="$1"
    local prefix="$2"
    local ar_uname=()

    grep "^${prefix}_u_.*=1$" "$fname" | sed "s/^${prefix}_u_//" | sed "s/=1$//"
    return $?
}


function lci_register () {
    local rootdir="$1"
    [[ -d "$rootdir" ]] && [[ -f "$rootdir/masterconf.sh" ]] || die "lci_register: $rootdir/masterconf.sh must exist"
    local newconf="path=$(realpath "$rootdir/masterconf.sh")"

    if [[ -f /etc/linuxconf.conf ]]; then
        local oldconf="$(grep ^path= /etc/linuxconf.conf 2>/dev/null)"
        [[ "$oldconf" = "$newconf" ]] && return 0
    fi

    # For new register (or register a different dir), clear all existing conf. This will trigger init again.
    echo "$newconf" | tee /etc/linuxconf.conf || die "lci_register failed, unable to write /etc/linuxconf.conf"
    chmod ugo+rw /etc/linuxconf.conf
}

function lci_init_if_needed () {
    local uname="$(whoami)"
    lci_state_file_contains /etc/linuxconf.conf init_done "$uname" && return 0

    # TODO: TODO: call init 
    
    lci_state_file_append /etc/linuxconf.conf init_done "$uname" || die "lc_init functions succeeded, but unable to update /etc/linuxconf.conf"
}

function lci_startup_if_needed () {
    # Arg1: Username. Leave empty to call startup for all user.
    local uname_="$1"

    local state_file=/tmp/.linuxconf-startup-state
    if [[ ! -f $state_file ]]; then
        touch $state_file && chmod ugo+rw $state_file || die "failed to create tmp file $state_file"
    fi

    if [[ "$uname_" = "" ]]; then
        [[ "$(whoami)" != root ]] && die "lci_startup_if_needed called for all user, but caller is not root. sudo might fail."
        local ar_uname=($(lci_state_file_list /etc/linuxconf.conf init_done)) || err "lci_state_file_list failed" || return $?
    else
        local ar_uname=("$uname_")
    fi

    for uname in "${ar_uname[@]}"; do
        lci_state_file_contains $state_file startup_done "$uname" && return 0
        # TODO: TODO: call startup
        # TODO: if this function only called once (from systemd as root), u must read user list from init_done_u_xxx & iterate. 
        #       if that's the case, startup_u still needed, because on first init, startup might be called multiple times for same user.
        lci_state_file_append $state_file startup_done "$uname" || die "lc_startup functions succeeded, but unable to update $state_file"
    done
}

subcommand="$1"
if [[ "$subcommand" = register ]]; then
    lci_register "$2"
    lci_init_if_needed
    lci_startup_if_needed "$(whoami)"
elif [[ "$subcommand" = _cron ]]; then
    # TODO
elif [[ "$subcommand" = _startup ]]; then
    lci_startup_if_needed
else
    lci_usage
    exit
fi

[[ ! -f /etc/linuxconf.conf ]] && echo "Please run '$0 register <Config Root Dir>' at least once" && exit 1

